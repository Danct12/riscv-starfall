--@name RV32IMA Emulator
--@author Danct12
--@owneronly

--[[
    Copyright 2025 Dang Huynh, you may use this file or any portions herein under any of the BSD, MIT, or CC0 licenses.
    
    Based on mini-rv32ima project (https://github.com/cnlohr/mini-rv32ima):
        Copyright 2022 Charles Lohr, you may use this file or any portions herein under any of the BSD, MIT, or CC0 licenses.
--]]

local myself = owner()
local chip = chip()

if SERVER then
    -- screen logic
    local curpos = 0
    local curline = 0
    local curcols = 0
    local lastkey = 0
    
    local Console
    local Keyboard
    local ConInit = false
    
    -- for 0x07 (BEL) escape code
    local beep = sound.create(chip, "hl1/fvox/beep.wav")

    wire.adjustInputs({ "Keyboard", "Console" }, { "Wirelink", "Wirelink" })    
    hook.add("input", "getwirelinks", function(name, val)
        if name == "Console" then
            Console = val
        elseif name == "Keyboard" then
            Keyboard = val
        end
    end)
    
    hook.add("Think", "kbloop", function()
        if not Keyboard then return end
        
        if Keyboard[0] > 0 then
            local keycode = Keyboard[1]
            -- Ignore shift keys
            if keycode == 154 or keycode == 155 then
                Keyboard[0] = 0
                return
            end
            net.start("keyboard")
            net.writeBool(true)
            net.writeUInt(keycode, 8)
            net.send()                
            Keyboard[0] = 0
        end
    end)

    local function clearScreen()
        Console[2041] = 1
        Console[2045] = 0
        Console[2046] = 1
        Console[2047] = 1 
    end
    
    local function scrollScreen(n)
        Console[2038] = n
    end
    
    local function printChar(char)
        local byte = char:byte(1)
        
        char_funcs = {            
            -- bell
            [0x07] = function()
                beep:stop()
                beep:play()
            end,
            
            -- backspace
            [0x08] = function()
                Console[curpos - 2] = 0
                curpos = curpos - 2
                Console[2045] = curpos
            end,
            
            -- tabstop
            [0x09] = function()
                curpos = curpos + 6
                Console[2045] = curpos
            end,
            
            -- line feed (new line)
            [0x0A] = function()
                local oldpos = Console[2045] - 2
                local newpos = oldpos + 60 - oldpos % 60
                
                if newpos >= 1080 then
                    scrollScreen(1)
                    newpos = 1020
                end
    
                curpos = newpos
                Console[2045] = curpos
            end,
        }
        -- carriage return
        char_funcs[0x0D] = char_funcs[0x0A]
        
        if char_funcs[byte] then
            char_funcs[byte]()
            return
        end
        
        if Console[2045] >= 1080 then
            scrollScreen(1)
            curpos = 1020
            Console[2045] = curpos
        end

        Console[curpos] = byte
        Console[curpos + 1] = 999
        curpos = curpos + 2
        Console[2045] = curpos
    end
    
    local function printString(chrstring)
        for i = 1, #chrstring, 1 do
            printChar(chrstring[i])
        end
    end
    
    -- this function reads client packet and send it to the screen
    net.receive("console", function(netlen, ply)
        if not Console then
            -- check if we have a screen
            return
        else
            -- make sure it's us who received the packet
            if ply ~= myself then return end

            local data = net.readString(netlen)

            -- initialize the display once we found it
            if ConInit == false then
                clearScreen()
                ConInit = true
            end
            
            printString(data)
        end
    end)
    
    -- chat logic
    hook.add("PlayerSay", "plyctrl", function(_ply, _text, _team, _isded)
        if _ply == owner() and _text[1] == "!" then
            local rest = string.sub(_text, 2, nil)
            local args = string.explode(" ", rest, true)
            
            if args[1] == "dumpstate" then
                print("Dump State")
            end 
        end
    end)
    
    return
end

image_path = "linuximage.bin"
dtb_path = "sixtyfourmb.dtb"

-- Predefs
ram_image_offset = 0x80000000
ram_size = 16*1024*1024 -- 16MB
ram_image = {}

os_image = ""
dtb_image = ""
os_size = 0
dtb_size = 0

-- will be filled below
dtb_ptr = 0
os_ptr = 0

-- As the owner spawning the chip, we're responsible for the OS image.
os_image = file.read(image_path)
assert(os_image, "Failed to load OS image")

os_size = string.len(os_image)
os_ptr = 0

dtb_image = file.read(dtb_path)
assert(dtb_image, "Failed to load DTB image")

dtb_size = string.len(dtb_image)
dtb_ptr = ram_size - dtb_size - 192

-- Persist variables
regs = {0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0}

pc = 0
mstatus = 0
cyclel = 0
cycleh = 0

timerl = 0
timerh = 0
timermatchl = 0
timermatchh = 0

mscratch = 0
mtvec = 0
mie = 0
mip = 0

mepc = 0
mtval = 0
mcause = 0

-- Note: only a few bits are used.  (Machine = 3, User = 0)
-- Bits 0..1 = privilege.
-- Bit 2 = WFI (Wait for interrupt)
-- Bit 3+ = Load/Store reservation LSBs.
extraflags = 0

-- console
conbuf = bit.stringstream()

-- keyboard
iskbhit = false
kbkey = 0
keyprocessed = true

local function quotaCheck(n)
    return math.max(quotaAverage(), quotaUsed()) < quotaMax()*n
end

local function toS8(n)
    if n >= 0x80 then return n - 0x100 end
    return n
end

local function toS16(n)
    if n >= 0x8000 then return n - 0x10000 end
    return n
end

local function toS32(n)
    if n >= 0x80000000 then return n - 0x100000000 end
    return n
end

local function toU32(n)
    if n < 0 then return n + 0x100000000 end
    return n
end

--[[
    LuaJIT bit binary handles bit differently.
    Usually right shfiting a bit beyond 0 will discard them
    but LuaJIT does not and return the old value.
--]]
local function bit_lshift64(n, shift)
    return n * (2 ^ shift)
end

local function bit_rshift64(n, shift)
    return math.floor(n / 2 ^ shift)
end

local function conSendClient(constring)
    net.start("console")
    net.writeString(constring)
    net.send()
end

local function rv32_div(n1, n2)
    if toS32(n1) == -2147483648 and toS32(n2) == -1 then
        return n1
    end

    local Val = toS32(n1) / toS32(n2)
    if Val > 0 then
        Val = math.floor(Val)
    else
        Val = math.round(Val)
    end
    return Val
end

local function rv32_mod(n1, n2)
    if toS32(n1) == -2147483648 and toS32(n2) == -1 then
        return 0
    elseif (n2 == 0) then
        return toS32(n1)
    end

    if toS32(n2) < 0 then
        return math.fmod(toS32(n1), bit.bnot(toS32(n2) - 1))
    end
    
    return math.fmod(toS32(n1), toS32(n2))
end

local function dumpstate()
    print(string.format("PC: %08x", pc))
    print(string.format("Z:%08x ra:%08x sp:%08x gp:%08x tp:%08x t0:%08x t1:%08x t2:%08x s0:%08x s1:%08x a0:%08x a1:%08x a2:%08x a3:%08x a4:%08x a5:%08x",
        regs[0], regs[1], regs[2], regs[3], regs[4], regs[5], regs[6], regs[7],
        regs[8], regs[9], regs[10], regs[11], regs[12], regs[13], regs[14], regs[15]))
    print(string.format("a6:%08x a7:%08x s2:%08x s3:%08x s4:%08x s5:%08x s6:%08x s7:%08x s8:%08x s9:%08x s10:%08x s11:%08x t3:%08x t4:%08x t5:%08x t6:%08x",
        regs[16], regs[17], regs[18], regs[19], regs[20], regs[21], regs[22], regs[23],
        regs[24], regs[25], regs[26], regs[27], regs[28], regs[29], regs[30], regs[31]))
end

local function rv32_store4(ofs, val)
    local byte1 = bit.band(val, 0xff)
    local byte2 = bit.band(bit.rshift(val, 8), 0xff)
    local byte3 = bit.band(bit.rshift(val, 16), 0xff)
    local byte4 = bit.band(bit.rshift(val, 24), 0xff)
    
    ram_image[ofs] = byte1
    ram_image[ofs + 1] = byte2
    ram_image[ofs + 2] = byte3
    ram_image[ofs + 3] = byte4
end

local function rv32_store2(ofs, val)
    local byte1 = bit.band(val, 0xff)
    local byte2 = bit.band(bit.rshift(val, 8), 0xff)
    ram_image[ofs] = byte1
    ram_image[ofs + 1] = byte2
end

local function rv32_store1(ofs, val)
    ram_image[ofs] = bit.band(val, 0xff)
end

local function rv32_load4(ofs)
    local byte1 = ram_image[ofs] or 0
    local byte2 = ram_image[ofs + 1] or 0
    local byte3 = ram_image[ofs + 2] or 0
    local byte4 = ram_image[ofs + 3] or 0
    
    local byte2 = bit.lshift(byte2, 8)
    local byte3 = bit.lshift(byte3, 16)
    local byte4 = bit.lshift(byte4, 24)
    
    local result = bit.bor(byte4, byte3, byte2, byte1)
    
    return result
end

local function rv32_load2(ofs)
    local byte1 = ram_image[ofs] or 0
    local byte2 = ram_image[ofs + 1] or 0
    
    local byte2 = bit.lshift(byte2, 8)
    
    local result = bit.bor(byte2, byte1)
    return result
end

local function rv32_load1(ofs)
    local result = ram_image[ofs] or 0
    return result
end

local function rv32_load2_signed(ofs)
    local byte = rv32_load2(ofs)
    return toS16(byte)
end

local function rv32_load1_signed(ofs)
    local byte = rv32_load1(ofs)
    return toS8(byte)
end

function rv32_handle_mem_load_control(addy)
    if addy == 0x10000005 then
        if iskbhit and not keyprocessed then
            return bit.bor(0x60, 1)
        else
            return 0x60
        end
    elseif addy == 0x10000000 and iskbhit then
        keyprocessed = true
        return kbkey
    elseif addy == 0x1100BFFC then
        return timerh
    elseif addy == 0x1100BFF8 then
        return timerl
    end
    
    return 0
end

local function rv32_handle_mem_store_control(addy, val)
    if addy == 0x10000000 then      -- UART 8250 / 16550 Data Buffer
        conbuf:writeUInt8(val)
    elseif addy == 0x11004004 then -- CLNT
        timermatchh = val
    elseif addy == 0x11004000 then -- CLNT
        timermatchl = val
    elseif addy == 0x11100000 then -- SYSCON (reboot, poweroff, etc.)
        pc = pc + 4
        return val -- NOTE: PC will be PC of Syscon.
    end

    return 0
end

local function rv32_othercsr_read(csrno)
    if csrno == 0x140 then
        if not iskbhit then return -1 end
        return kbkey
    end
    
    return 0
end

local function rv32_othercsr_write(csrno, val)
    if csrno == 0x136 then
        print(val)
    end

    if csrno == 0x137 then
        conSendClient(string.format("%08x", val))
    elseif csrno == 0x138 then
        local ptrstart = val - ram_image_offset
        local ptrend = ptrstart
        local i = 0
        local j = 0
        local str = ""
        
        if ptrstart >= ram_size then
            print(string.format("DEBUG PASSED INVALID PTR (%08x)", val))
        end
        
        while ptrend < RAM_SIZE do
            if ram_image[ptrend] == 0 then break end
            ptrend = ptrend + 1
        end

        for i = ptrstart, ptrend - 1, 1 do
            str = ram_image[i]
        end
        
        conSendClient(str)
        
    elseif( csrno == 0x139 ) then
        conSendClient(string.char(val))
    end
end

local function rv32_handle_exception(ir, retval)
    if retval == 3 then
        assert(0)
    end
    
    return retval
end

local function rv32_postexec(pc, ir, retval)
    if retval > 0 then
        retval = rv32_handle_exception(ir, retval)
    end
end

local function rv32_ima_step(elapsedus, count)
    local new_timer = timerl + elapsedus
    if new_timer < timerl then
        timerh = timerh + 1
    end
    timerl = new_timer

    -- Handle Timer interrupt.
    if timerh > timermatchh or timerh == timermatchh and timerl > timermatchl and (timermatchh or timermatchl) then
        extraflags = bit.band(extraflags, (bit.bnot(4))) -- Clear WFI
        mip = bit.bor(mip, bit.lshift(1, 7)) -- MTIP of MIP -- https://stackoverflow.com/a/61916199/2926815  Fire interrupt.
    else
        mip = bit.band(mip ,(bit.bnot(bit.lshift(1, 7))))
    end
    
    -- If WFI, don't run processor.
    if bit.band(extraflags, 4) != 0 then
        return 1
    end
    
    local trap = 0
    local rval = 0
    local cycle = cyclel

    if bit.band(mip, bit.lshift(1, 7)) != 0 and bit.band(mie, bit.lshift(1, 7)) != 0 and bit.band(mstatus, 0x8) != 0 then
        -- Timer interrupt.
        trap = 0x80000007
        pc = pc - 4
    else
        local icount = 0
        while quotaCheck(0.90) and icount < count do
            local ir = 0
            rval = 0
            cycle = cycle + 1
            local ofs_pc = pc - ram_image_offset

            if ofs_pc >= ram_size or ofs_pc < 0 then
                trap = 1 + 1 -- Handle access violation on instruction read.
                break
            elseif bit.band(ofs_pc, 3) != 0 then
                trap = 1 + 0 -- Handle PC-misaligned access
                break
            else
                ir = rv32_load4(ofs_pc)
                rdid = bit.band(bit.rshift(ir, 7), 0x1F)

                local ir_switch = bit.band(ir, 0x7f)
                
                if ir_switch == 0x37 then -- LUI (0b0110111)
                        rval = bit.band(ir, 0xFFFFF000)
                elseif ir_switch == 0x17 then -- AUIPC (0b0010111)
                        rval = pc + bit.band(ir, 0xFFFFF000)
                elseif ir_switch == 0x6F then -- JAL (0b1101111)
                        local reladdy = bit.bor(bit.rshift(bit.band(ir, 0x80000000), 11),
                                                bit.rshift(bit.band(ir, 0x7FE00000), 20),
                                                bit.rshift(bit.band(ir, 0x00100000), 9),
                                                bit.band(ir, 0x000FF000))
                        if bit.band(reladdy, 0x00100000) != 0 then
                            reladdy = bit.bor(reladdy, 0xFFE00000)
                        end -- Sign extension.
                        rval = pc + 4
                        pc = pc + reladdy - 4
                elseif ir_switch == 0x67 then -- JALR (0b1100111)
                        local imm = bit.rshift(ir, 20)
    
                        local imm_se_tmp = 0                    
                        if bit.band(imm, 0x800) != 0 then
                            imm_se_tmp = 0xFFFFF000
                        end
                        
                        local imm_se = bit.bor(imm, imm_se_tmp)
                        rval = pc + 4
                        --PC = ( (Reg[((IR >> 15) && 0x1F), number] + IMM_SE) && bNot(1)) - 4
                        pc = ( (regs[bit.band(bit.rshift(ir, 15), 0x1F)] + imm_se) ) - 4
                elseif ir_switch == 0x63 then -- Branch (0b1100011)
                        local immm4 = bit.bor(bit.rshift(bit.band(ir, 0xF00), 7),
                                            bit.rshift(bit.band(ir, 0x7E000000), 20),
                                            bit.lshift(bit.band(ir, 0x80), 4),
                                            bit.lshift(bit.rshift(ir, 31), 12))
                        if bit.band(immm4, 0x1000) != 0 then
                            immm4 = bit.bor(immm4, 0xFFFFE000)
                        end
                        -- TODO: These are signed integers
                        local rs1 = toS32( regs[bit.band(bit.rshift(ir, 15), 0x1F)] )
                        local rs2 = toS32( regs[bit.band(bit.rshift(ir, 20), 0x1F)] )
                        immm4 = pc + immm4 - 4
                        rdid = 0
                        local ir_btemp = bit.band(bit.rshift(ir, 12), 0x7)
                        -- BEQ, BNE, BLT, BGE, BLTU, BGEU
                        if ir_btemp == 0 then -- BEQ
                            if rs1 == rs2 then
                                pc = immm4
                            end
                        elseif ir_btemp == 1 then -- BNE
                            if rs1 != rs2 then
                                pc = immm4
                            end
                        elseif ir_btemp == 4 then -- BLT
                            if rs1 < rs2 then
                                pc = immm4
                            end
                        elseif ir_btemp == 5 then -- BGE
                            if rs1 >= rs2 then
                                pc = immm4
                            end
                        elseif ir_btemp == 6 then -- BLTU
                            if toU32(rs1) < toU32(rs2) then
                                pc = immm4
                            end
                        elseif ir_btemp == 7 then -- BGEU
                            if toU32(rs1) >= toU32(rs2) then
                                pc = immm4
                            end
                        else
                            trap = (2+1)
                        end

                elseif ir_switch == 0x03 then -- Load (0b0000011)
                    local rs1 = regs[bit.band(bit.rshift(ir, 15), 0x1F)]
                    local imm = bit.rshift(ir, 20)
                    local imm_se = imm
                    if bit.band(imm, 0x800) != 0 then
                        imm_se = bit.bor(imm, 0xFFFFF000)
                    end
                    
                    local rsval = rs1 + imm_se
                    rsval = rsval - ram_image_offset
                    
                    if toU32(rsval) >= ram_size - 3 then
                        rsval = rsval + ram_image_offset
                        if (0x10000000 <= rsval) and (rsval < 0x12000000) then -- UART, CLNT
                                rval = rv32_handle_mem_load_control(rsval)
                        else
                            trap = (5+1)
                            rval = rsval
                        end
                    else
                        local ir_ltemp = bit.band(bit.rshift(ir, 12), 0x7)
                        if ir_ltemp == 0 then -- LB
                                rval = rv32_load1_signed(rsval)
                        elseif ir_ltemp == 1 then -- LH
                                rval = rv32_load2_signed(rsval)
                        elseif ir_ltemp == 2 then -- LW
                                rval = rv32_load4(rsval)
                        elseif ir_ltemp == 4 then -- LBU
                                rval = rv32_load1(rsval)
                        elseif ir_ltemp == 5 then -- LHU
                                rval = rv32_load2(rsval)
                        else
                                trap = (2+1)
                        end
                    end

                elseif ir_switch == 0x23 then -- Store 0b0100011
                    local rs1 = regs[bit.band(bit.rshift(ir, 15), 0x1F)]
                    local rs2 = regs[bit.band(bit.rshift(ir, 20), 0x1F)]
                    local addy = bit.bor(bit.band(bit.rshift(ir, 7), 0x1F), bit.rshift(bit.band(ir, 0xFE000000), 20))
                    
                    if bit.band(addy, 0x800) != 0 then
                        addy = bit.bor(addy, 0xFFFFF000)
                    end
                    
                    addy = addy + (rs1 - ram_image_offset)
                    rdid = 0
                    
                    if toU32(addy) >= ram_size - 3 then                        
                        addy = addy + ram_image_offset

                        if (0x10000000 <= addy) and (addy < 0x12000000) then
                            if rv32_handle_mem_store_control(addy, rs2) != 0 then
                                return rs2
                            end
                        else
                            trap = (7+1) -- Store access fault.
                            print(string.format("Store access fault at 0x%X", addy))
                            rval = addy
                        end
                    else
                        local ir_stmp = bit.band(bit.rshift(ir, 12), 0x7)
                        if ir_stmp == 0 then
                                rv32_store1(addy, rs2) -- SB
                        elseif ir_stmp == 1 then
                                rv32_store2(addy, rs2) -- SH
                        elseif ir_stmp == 2 then
                                rv32_store4(addy, rs2) -- SW
                        else
                                trap = (2+1)
                        end
                    end

                elseif ir_switch == 0x13 or   -- Op-immediate 0b0010011
                       ir_switch == 0x33 then -- Op           0b0110011
                    local imm = bit.rshift(ir, 20)
                    if bit.band(imm, 0x800) != 0 then
                        imm = bit.bor(imm, 0xFFFFF000)
                    end
                    
                    local rs1 = regs[bit.band(bit.rshift(ir, 15), 0x1F)]
                    local is_reg = bit.band(ir, 0x20 ) != 0

                    local rs2 = imm
                    if is_reg == true then
                        rs2 = regs[bit.band(imm, 0x1F)]
                    end

                    if is_reg == true and bit.band(ir, 0x02000000) != 0 then
                        local ir_optmp = bit.band(bit.rshift(ir, 12), 7) -- 0x02000000 = RV32M
                        -- TODO: These aren't all correct, double check.
                        if ir_optmp == 0 then -- MUL
                                rval = bit.band((toS32(rs1) * toS32(rs2)), 0xFFFFFFFF)
                        elseif ir_optmp == 1 then -- MULH
                                rval = bit_rshift64(toS32(rs1) * toS32(rs2), 32)
                        elseif ir_optmp == 2 then -- MULHSU
                                rval = bit_rshift64(toS32(rs1) * rs2, 32)
                        elseif ir_optmp == 3 then -- MULHU
                                rval = bit_rshift64(rs1 * rs2, 32)
                        elseif ir_optmp == 4 then -- DIV
                                if rs2 == 0 then
                                    rval = -1
                                else
                                    rval = rv32_div(rs1, rs2)
                                end
                        elseif ir_optmp == 5 then -- DIVU
                                if rs2 == 0 then
                                    rval = 0xFFFFFFFF
                                else
                                    rval = toU32(math.floor(rs1 / rs2))
                                end
                        elseif ir_optmp == 6 then -- REM
                                if rs2 == 0 then
                                    rval = rs1
                                else
                                    rval = rv32_mod(rs1, rs2)
                                end
                        elseif ir_optmp == 7 then -- REMU
                                if rs2 == 0 then
                                    rval = rs1
                                else
                                    rval = toU32(rs1) % toU32(rs2)
                                end
                        end
                    else                        
                        -- These could be either op-immediate or op commands.  Be careful.
                        local ir_opetmp = bit.band(bit.rshift(ir, 12), 7)
                        if ir_opetmp == 0 then
                            if is_reg == true and bit.band(ir, 0x40000000) != 0 then
                                rval = toS32(rs1 - rs2)
                            else
                                rval = toS32(rs1 + rs2)
                            end

                        elseif ir_opetmp == 1 then
                                rval = bit.lshift(rs1, bit.band(rs2, 0x1F))
                        elseif ir_opetmp == 2 then
                                if toS32(rs1) < toS32(rs2) then rval = 1 else rval = 0 end
                        elseif ir_opetmp == 3 then
                                if rs1 < rs2 then rval = 1 else rval = 0 end
                        elseif ir_opetmp == 4 then
                                rval = bit.bxor(rs1, rs2)
                        elseif ir_opetmp == 5 then
                            if bit.band(ir, 0x40000000) != 0 then
                                rval = bit.arshift(toS32(rs1), bit.band(rs2, 0x1F)) 
                            else
                                rval = bit.rshift(rs1, bit.band(rs2, 0x1F))
                            end
                        elseif ir_opetmp == 6 then
                                rval = bit.bor(rs1, rs2)
                        elseif ir_opetmp == 7 then
                                rval = bit.band(rs1, rs2)
                        end
                    end

                elseif ir_switch == 0x0F then -- 0b0001111
                    rdid = 0   -- fencetype = (ir >> 12) & 0b111; We ignore fences in this impl.
                elseif ir_switch == 0x73 then -- Zifencei+Zicsr  (0b1110011)
                    local csrno = bit.rshift(ir, 20)
                    local microop = bit.band(bit.rshift(ir, 12), 0x7)
                    if bit.band(microop, 3) != 0 then -- It's a Zicsr function.
                        local rs1imm = bit.band(bit.rshift(ir, 15), 0x1F)
                        local rs1 = regs[rs1imm]
                        local writeval = rs1

                        -- https://raw.githubusercontent.com/riscv/virtual-memory/main/specs/663-Svpbmt.pdf
                        -- Generally, support for Zicsr
                        if csrno == 0x340 then
                            rval = mscratch
                        elseif csrno == 0x305 then
                            rval = mtvec
                        elseif csrno == 0x304 then
                            rval = mie
                        elseif csrno == 0xC00 then
                            rval = cycle
                        elseif csrno == 0x344 then
                            rval = mip
                        elseif csrno == 0x341 then
                            rval = mepc
                        elseif csrno == 0x300 then
                            rval = mstatus
                        elseif csrno == 0x342 then
                            rval = mcause
                        elseif csrno == 0x343 then
                            rval = mtval
                        elseif csrno == 0xF11 then
                            rval = 0xFF0FF0FF -- mvendorid
                        elseif csrno == 0x301 then
                            rval = 0x40401101 -- misa (XLEN=32, IMA+X)

                            --[[ Everything here are commented out.
                                                case 0x3B0: rval = 0; break; --pmpaddr0
                                                case 0x3a0: rval = 0; break; --pmpcfg0
                                                case 0xf12: rval = 0x00000000; break; --marchid
                                                case 0xf13: rval = 0x00000000; break; --mimpid
                                                case 0xf14: rval = 0x00000000; break; --mhartid
                            --]]

                        else
                            rval = rv32_othercsr_read(csrno)
                        end

                        if microop == 1 then
                            writeval = rs1 -- CSRRW
                        elseif microop == 2 then
                            writeval = bit.bor(rval, rs1) -- CSRRS
                        elseif microop == 3 then
                            writeval = bit.band(rval, bit.bnot(rs1)) -- CSRRC
                        elseif microop == 5 then
                            writeval = rs1imm -- CSRRWI
                        elseif microop == 6 then
                            writeval = bit.bor(rval, rs1imm) -- CSRRSI
                        elseif microop == 7 then
                            writeval = bit.band(rval, bit.bnot(rs1imm)) -- CSRRCI
                        end

                        if csrno == 0x340 then
                            mscratch = writeval
                        elseif csrno == 0x305 then
                                mtvec = writeval
                        elseif csrno == 0x304 then
                                mie = writeval
                        elseif csrno == 0x344 then
                                mip = writeval
                        elseif csrno == 0x341 then
                                mepc = writeval
                        elseif csrno == 0x300 then
                                mstatus = writeval
                        elseif csrno == 0x342 then
                                mcause = writeval
                        elseif csrno == 0x343 then
                                mtval = writeval

                            -- These were commented out.
                            --case 0x3a0: break; --pmpcfg0
                            --case 0x3B0: break; --pmpaddr0
                            --case 0xf11: break; --mvendorid
                            --case 0xf12: break; --marchid
                            --case 0xf13: break; --mimpid
                            --case 0xf14: break; --mhartid
                            --case 0x301: break; --misa
                        else
                            rv32_othercsr_write(csrno, writeval)
                        end
                        elseif microop == 0x0 then -- "SYSTEM" 0b000
                            rdid = 0
                            if csrno == 0x105 then                  -- WFI (Wait for interrupts)
                                mstatus = bit.bor(mstatus, 8)       -- Enable interrupts
                                extraflags = bit.bor(extraflags, 4) -- Infor environment we want to go to sleep.
                                pc = pc + 4
                                return 1
                            elseif bit.band(csrno, 0xFF) == 0x02 then -- MRET
                                -- https://raw.githubusercontent.com/riscv/virtual-memory/main/specs/663-Svpbmt.pdf
                                -- Table 7.6. MRET then in mstatus/mstatush sets MPV=0, MPP=0, MIE=MPIE, and MPIE=1. La
                                -- Should also update mstatus to reflect correct mode.
                                local startmstatus = mstatus
                                local startextraflags = extraflags
                                mstatus = bit.bor(bit.rshift(bit.band(startmstatus, 0x80), 4), bit.lshift(bit.band(startextraflags, 3), 11), 0x80)
                                extraflags = bit.bor(bit.band(startextraflags, bit.bnot(3)), bit.band(bit.rshift(startmstatus, 11), 3))
                                pc = mepc - 4
                            else
                                if csrno == 0 then -- ECALL; 8 = "Environment call from U-mode";
                                                   --       11 = "Environment call from M-mode"
                                    if bit.band(extraflags, 3) != 0 then
                                        trap = (11+1)
                                    else
                                        trap = (8+1)
                                    end
                                elseif csrno == 1 then -- EBREAK 3 = "Breakpoint"
                                    trap = (3+1)
                                elseif csrno == 0x105 then -- WFI
                                    mstatus = bit.bor(mstatus, 8)
                                    extraflags = bit.bor(extraflags, 4)
                                    pc = pc + 4
                                else
                                    trap = (2+1) -- Illegal opcode.
                                end
                            end
                        else
                            trap = (2+1) -- Note micrrop 0b100 == undefined.
                        end
                elseif ir_switch == 0x2F then -- RV32A (0b00101111)
                    local rs1 = regs[bit.band(bit.rshift(ir, 15), 0x1F)]
                    local rs2 = regs[bit.band(bit.rshift(ir, 20), 0x1F)]
                    local irmid = bit.band(bit.rshift(ir, 27), 0x1F)

                    rs1 = rs1 - ram_image_offset

                    -- We don't implement load/store from UART or CLNT with RV32A here.
                    if rs1 >= ram_size - 3 then
                        trap = (7+1) -- Store/AMO access fault
                        rval = rs1 + ram_image_offset
                    else
                        rval = rv32_load4(rs1)
                        
                        -- Referenced a little bit of https://github.com/franzflasch/riscv_em/blob/master/src/core/core.c
                        local dowrite = true
                        
                        if irmid == 2 then -- LR.W (0b00010)
                            dowrite = false
                            extraflags = bit.bor(bit.band(extraflags, 0x07), bit.lshift(rs1, 3))
                        elseif irmid == 3 then -- SC.W (0b00011) (Make sure we have a slot, and, it's valid)
                            rval = bit.rshift(extraflags, 3) != bit.band(rs1, 0x1FFFFFFF) -- Validate that our reservation slot is OK.
                            dowrite = !rval -- Only write if slot is valid.
                            if dowrite then rval = 0 else rval = 1 end
                        elseif irmid == 1 then -- AMOSWAP.W (0b00001)
                            -- do nothing

                        elseif irmid == 0 then -- AMOADD.W (0b00000)
                            rs2 = rs2 + rval
                        elseif irmid == 4 then -- AMOXOR.W (0b00100)
                            rs2 = bit.bxor(rs2, rval)
                        elseif irmid == 12 then -- AMOAND.W (0b01100)
                            rs2 = bit.band(rs2, rval)
                        elseif irmid == 8 then -- AMOOR.W (0b01000)
                            rs2 = bit.bor(rs2, rval)
                        elseif irmid == 16 then -- AMOMIN.W (0b10000)
                            if toS32(rs2) < toS32(rval) then
                                rs2 = rs2
                            else
                                rs2 = rval
                            end
                        elseif irmid == 20 then -- AMOMAX.W (0b10100)
                            if toS32(rs2) > toS32(rval) then
                                rs2 = rs2
                            else
                                rs2 = rval
                            end

                        elseif irmid == 24 then -- AMOMINU.W (0b11000)                                        
                            if rs2 < rval then
                                rs2 = rs2
                            else
                                rs2 = rval
                            end
                        elseif irmid == 28 then -- AMOMAXU.W (0b11100)
                            if rs2 > rval then
                                rs2 = rs2
                            else
                                rs2 = rval
                            end
                        else -- Not supported.
                            trap = (2+1)
                            dowrite = false
                        end
                        
                        if dowrite then
                            rv32_store4(rs1, rs2)
                        end
                    end
                else
                    trap = (2+1) -- Fault: Invalid opcode.
                end
                    
                -- If there was a trap, do NOT allow register writeback.
                if trap != 0 then
                    rv32_postexec(pc, ir, trap)
                    break
                end
                    
                if rdid != 0 then
                    -- Write back register.
                    regs[rdid] = toU32(rval)
                end
            end
            
            rv32_postexec(pc, ir, trap)
            pc = pc + 4
        end
    end

    -- Handle traps and interrupts.
    if trap != 0 then
        if bit.band(trap, 0x80000000) != 0 then -- If prefixed with 1 in MSB, it's an interrupt, not a trap.
            mcause = trap
            mtval = 0
            pc = pc + 4 -- PC needs to point to where the PC will return to.
        else
            mcause = trap - 1
            
            if trap > 5 and trap <= 8 then
                mtval = rval
            else
                mtval = pc
            end
        end

        mepc = pc -- TRICKY: The kernel advances mepc automatically.
        -- #CSR( mstatus ) & 8 = MIE, & 0x80 = MPIE
        -- On an interrupt, the system moves current MIE into MPIE
        mstatus = bit.bor(bit.lshift(bit.band(mstatus, 0x08), 4), bit.lshift(bit.band(extraflags, 3), 11))
        pc = (mtvec - 4)

        -- If trapping, always enter machine mode.
        extraflags = bit.bor(extraflags, 3)
        trap = 0
        pc = pc + 4
    end

    if cyclel > cycle then
        cycleh = cycleh + 1
    end
    
    cyclel = cycle
    pc = pc

    return 0
end

-- DATA INITIALIZATION
local function start_emu()
    -- Load device tree blob to RAM
    assert(type(dtb_image) == "string", "dtb image is not file")

    print(string.format("dtb ptr: 0x%x - size: 0x%x", dtb_ptr, dtb_size))

    pc = ram_image_offset
    regs[0] = 0 -- first value is null
    regs[10] = 0x00
    regs[11] = ram_image_offset + dtb_ptr
    extraflags = bit.bor(extraflags, 3)

    local dtb_ram = rv32_load4(dtb_ptr + 0x13c)
    if dtb_ram == 0x00C0FF03 then
        local valid_ram = dtb_ptr
        
        --[[
            Device tree integer are big-endian, so we cannot use our
            store function to write valid_ram directly.
            
            I would write a helper too but it's unlikely there's any
            other big-endian tasks aside from that.
        --]]
        local byte1 = bit.band(valid_ram, 0xff)
        local byte2 = bit.band(bit.rshift(valid_ram, 8), 0xff)
        local byte3 = bit.band(bit.rshift(valid_ram, 16), 0xff)
        local byte4 = bit.band(bit.rshift(valid_ram, 24), 0xff)
        local validram_be = byte1 * 0x1000000 + byte2 * 0x10000 + byte3 * 0x100 + byte4
        
        rv32_store4(dtb_ptr + 0x13c, validram_be)
    end
    
    print("Emulation Started!")
    
    local last_us = math.floor(timer.realtime() * 1000000)
    
    timer.create("rv32_step", 0, 0, function()
        local single_step = 0
        local instrs_per_flip = 0
        local instr_count = 0
        
        if single_step then
            instrs_per_flip = 1
            instr_count = 1
        else
            instrs_per_flip = 1024
            instr_count = 1
        end
        
        if single_step == 1 then
            dumpstate()
        end
    
        local elapsed_us = math.floor((timer.realtime() * 1000000)) - last_us
        last_us = last_us + elapsed_us
        local i = 0
        while (quotaCheck(0.90) and i < instr_count) do
            local ret = rv32_ima_step(elapsed_us, instrs_per_flip) -- Execute upto 1024 cycles before breaking out.
            if ret == 0 or ret == 1 then
                -- do nothing
            elseif ret == 0x7777 then
                restart(nil)
            elseif ret == 0x5555 then
                assert(nil, "CPU halted")
            else
                assert(nil, "Unknown failure")
            end
            i = i + 1
        end
    end) 
end

start_time = timer.systime()

print(string.format("Loading DTB and OS to RAM"))

dtb_buf = 0
dtb_done = 0
os_buf = 0
os_done = 0
ram_buf = 0
ram_done = 0
timer.create("fillram", 0, 0, function()
    if dtb_done == 0 then
        while quotaCheck(0.90) and dtb_buf < dtb_size do
            ram_image[dtb_ptr + dtb_buf] = string.byte(dtb_image, dtb_buf + 1, nil)
            dtb_buf = dtb_buf + 1
        end
        
        if dtb_buf >= dtb_size then
            dtb_done = 1
            print("Finished loading DTB image")
        end
    end

    if os_done == 0 then
        while quotaCheck(0.90) and os_buf < os_size do
            ram_image[os_ptr + os_buf] = string.byte(os_image, os_buf + 1, nil)
            os_buf = os_buf + 1
        end
        
        if os_buf >= os_size then
            os_done = 1
            print("Finished loading OS image")
        end
    end
    
    if dtb_done == 1 and os_done == 1 then
        timer.remove("fillram")
        print(string.format("Took %d seconds to load OS and DTB", timer.systime() - start_time, buf_fill))
        start_emu()
    end
end)

local function conFlush()
    conSendClient(conbuf:getString())
    conbuf = bit.stringstream()
end

console_starttime = timer.systime()

hook.add("Tick", "conbuf", function()
    console_curtime = timer.systime()
    while(quotaCheck(0.90) and conbuf:size() > 0 and console_curtime - console_starttime > 0.5) do
        conFlush()
        console_starttime = timer.systime()
    end
end)

net.receive("keyboard", function(netlen, ply)
    if keyprocessed then
        iskbhit = net.readBool(8)
        if iskbhit then
            kbkey = net.readUInt(8)
            keyprocessed = false
        else
            kbkey = -1
        end
    end
end)

-- vim: set ft=lua ts=4 et :
